'''
All name related errors.

NOTE: This linter attempts to aggregate all of the linters that require a 
	full traversal of the AST.  The other linters make use of one of the 
	higher level trees.
'''
__author__ = 'Terrence Cole <terrence@zettabytestorage.com>'

from millipede.py.common.visitor import ASTVisitor
from millipede.lint.common import BUILTINS, KEYWORDS
from millipede.lint.messages import \
	W0611, W0612, W0613, W0614, W0615, W0621, W0622, W0631, W0702, \
	E0601, E0602, E0603
import millipede.py.py3.ast as ast
from contextlib import contextmanager



class Binding:
	def __init__(self, node:ast.AST, location:str):
		# the lower-level AST definition
		self.node = node

		# this should be a Name or Attribute; store aside its value
		self.value = node.id

		# whether this binding has been accessed
		self.used = False

		# whether this binding has been unbound
		self.unbound = False

		# the location where this binding occurred
		self.location = location


class InvalidAccess:
	def __init__(self, node:ast.AST, is_unbound:bool):
		# the lower-level AST definition
		self.node = node

		# whether or not the access is simply unbound or fully not-present
		self.is_unbound = is_unbound


class Scope:
	def __init__(self, parent, context, type_:str):
		# the scope above this one, or None if toplevel
		self.parent = parent

		# a string specifying a type this scope represents, e.g. 'module'
		self.type = type_

		# maps names to bindings
		self.names = {}

		# the __Visitor instance that generated us
		# NOTE: only valid until the scope is finalized
		self.context = context

		# we have to store asside undefined access errors so that we can
		#	distinguish used-before-defined and completely-undefined
		self.invalid_access = []


	def finalize(self):
		for name, binding in self.names.items():
			if not binding.used:
				if binding.location == 'import':
					self.context.messages.append(
						W0611(binding.node, None, binding.value))
				elif binding.location == 'argument':
					self.context.messages.append(
						W0613(binding.node, None, binding.value))
				elif binding.location == 'with':
					self.context.messages.append(
						W0615(binding.node, None, binding.value))
				elif binding.location == 'classdef' or \
						binding.location == 'functiondef':
					pass
				else:
					self.context.messages.append(
						W0612(binding.node, None, binding.value))

		for inv in self.invalid_access:
			ERR = E0602 # undefined
			if inv.node.id in self.names:
				ERR = E0601 # used before defined
			if inv.is_unbound:
				ERR = E0603 # used after del
			self.context.messages.append(ERR(inv.node, None, inv.node.id))

		del self.context


	def bind(self, node):
		#print("BIND  ({}): {}".format(self.type,node.id))
		self.names[node.id] = Binding(node, self.context.location_context)


	def lookup(self, node):
		#print("LOOKUP({}): {}".format(self.type,node.id))
		if node.id not in self.names or self.names[node.id].unbound:
			if self.parent:
				try:
					return self.parent.lookup(node)
				except KeyError:
					is_unbound = node.id in self.names
					assert not is_unbound or self.names[node.id].unbound
					self.invalid_access.append(InvalidAccess(node, is_unbound))
					return None
			else:
				raise KeyError(node.id)

		self.names[node.id].used = True
		return self.names[node.id]


	def unbind(self, node):
		#print("UNBIND({}): {}".format(self.type,node.id))
		try:
			binding = self.lookup(node)
			binding.unbound = True
		except KeyError:
			return



class BuiltinScope(Scope):
	'''A special scope that contains python's builtins'''

	class FakeName:
		'''A stub that looks like an ast.Name, used by the BuiltinScope to
			make its strings look like the Names stored in other scopes.'''
		def __init__(self, name):
			self.id = name
			self.ctx = ast.Store

	def __init__(self, parent, context, type_):
		super().__init__(parent, context, type_)
		for name in BUILTINS:
			self.names[name] = Binding(self.FakeName(name), 'builtin')



class __Visitor(ASTVisitor):
	def __init__(self):
		super().__init__()

		# a string representing the current symbol access/definition location
		self.location_context = 'toplevel'

		# track message generated by visiting the AST
		self.messages = []

		# the scope stack, starting with builtins at the bottom
		self.scopes = [
			BuiltinScope(None, self, 'builtins')
		]


	@property
	def scope(self):
		return self.scopes[-1]


	@contextmanager
	def location(self, location:str):
		oldloc = self.location_context
		self.location_context = location
		yield
		self.location_context = oldloc


	def visit_Module(self, node):
		self.scopes.append(Scope(self.scope, self, 'module'))

		for stmt in node.body:
			self.visit(stmt)

		self.scope.finalize()
		self.scopes.pop()


	def visit_ImportFrom(self, node):
		with self.location('import'):
			for alias in node.names:
				name = alias.asname or alias.name
				while isinstance(name, ast.Attribute):
					name = name.value
				self.scope.bind(name)


	def visit_Import(self, node):
		with self.location('import'):
			for alias in node.names:
				name = alias.asname or alias.name
				while isinstance(name, ast.Attribute):
					name = name.value
				self.scope.bind(name)


	def visit_FunctionDef(self, node):
		# annotations and defaults are evaluated in enclosing context
		if node.returns:
			self.visit(node.returns)
		if node.args.args:
			for arg in node.args.args:
				if arg.annotation:
					self.visit(arg.annotation)
		if node.args.varargannotation:
			self.visit(node.args.varargannotation)
		if node.args.kwonlyargs:
			for arg in node.args.kwonlyargs:
				if arg.annotation:
					self.visit(arg.annotation)
		if node.args.kwargannotation:
			self.visit(node.args.kwargannotation)
		if node.args.defaults:
			for expr in node.args.defaults:
				self.visit(expr)
		if node.args.kw_defaults:
			for expr in node.args.kw_defaults:
				self.visit(expr)

		# push the new scope
		self.scopes.append(Scope(self.scope, self, 'function'))

		# the arg definitions are made in the new level
		with self.location('argument'):
			if node.args.args:
				for arg in node.args.args:
					self.scope.bind(arg.arg)
			if node.args.vararg:
				self.scope.bind(node.args.vararg)
			if node.args.kwonlyargs:
				for arg in node.args.kwonlyargs:
					self.scope.bind(arg.arg)
			if node.args.kwarg:
				self.scope.bind(node.args.kwarg)

		# evaluate function body
		for stmt in node.body:
			self.visit(stmt)

		# finished with this scope
		self.scope.finalize()
		self.scopes.pop()

		# decorators are visited in enclosing level, after evaluating sub-level
		if node.decorator_list:
			for deco in node.decorator_list:
				self.visit(deco)

		# bind the function name into the enclosing scope after definition
		with self.location('functiondef'):
			self.scope.bind(node.name)


	def visit_With(self, node):
		self.visit(node.context_expr)
		with self.location('with'):
			self.visit(node.optional_vars)
		for stmt in node.body:
			self.visit(stmt)


	def visit_ClassDef(self, node):
		# bases, keywords, starargs, and kwargs are evaluated outside the scope
		if node.bases:
			for base in node.bases:
				self.visit(base)
		if node.keywords:
			for kw in node.keywords:
				self.visit(kw)
		if node.starargs:
			self.visit(node.starargs)
		if node.kwargs:
			self.visit(node.kwargs)

		# push the new scope
		self.scopes.append(Scope(self.scope, self, 'class'))

		# evaluate function body
		for stmt in node.body:
			self.visit(stmt)

		# finished with this scope
		self.scope.finalize()
		self.scopes.pop()

		# decorators are visited in enclosing level, after evaluating sub-level
		if node.decorator_list:
			for deco in node.decorator_list:
				self.visit(deco)

		# bind the function name into the enclosing scope after definition
		with self.location('classdef'):
			self.scope.bind(node.name)


	def visit_Name(self, node):
		#print("NAME:", node.id, node.ctx)
		if node.ctx == ast.Load or node.ctx == ast.Aug:
			self.scope.lookup(node)
		if node.ctx == ast.Store or node.ctx == ast.Aug:
			self.scope.bind(node)
		if node.ctx == ast.Del:
			self.scope.unbind(node)


	def visit_Attribute(self, node):
		#FIXME: can we look inside of the value to see if attr exists there?
		self.visit(node.value)


def analyse(unit):
	v = __Visitor()
	v.visit(unit.ast)

	for m in v.messages:
		yield m


def analyse_old(unit):
	print(unit.opmap.as_string())

	messages = []
	g = {b: True for b in BUILTINS}
	def _check_in_scope(opmap):
		# track locals, or globals at module scope
		l = {}
		if opmap.__class__.__name__ == 'ModuleScope':
			l = g

		# detected use-before definition
		detected = {}

		# move to used if we use them
		used = {}

		# check each symbol
		for sym, node in opmap.mappings.items():
			if sym.name in KEYWORDS: continue
			if sym.op == Store:
				l[sym.name] = True
				if sym.name in detected:
					used[sym.name] = detected[sym.name]
					del detected[sym.name]
			elif sym.op == Load:
				if sym.name not in l and sym.name not in g:
					detected[sym.name] = (sym, node)
			elif sym.op == Del:
				if sym.name in l:
					del l[sym.name]
				elif sym.name in g:
					del g[sym.name]
				else:
					detected[sym.name] = (sym, node)

			if isinstance(node, SymbolOpMap):
				_check_in_scope(node)

		# undefined
		for name, (sym, node) in detected.items():
			messages.append(Error('E0602', node))

		# assigned before used
		for name, (sym, node) in used.items():
			messages.append(Error('E0601', node))

	_check_in_scope(unit.opmap)
	return messages

